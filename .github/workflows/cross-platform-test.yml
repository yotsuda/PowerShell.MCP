name: Cross-Platform Test

on:
  workflow_dispatch:  # Manual trigger
  push:
    branches: [ main ]
    paths:
      - 'PowerShell.MCP/**'
      - 'PowerShell.MCP.Proxy/**'
      - 'Staging/**'


permissions:
  contents: read

jobs:
  test:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            rid: win-x64
            exe: PowerShell.MCP.Proxy.exe
          - os: ubuntu-latest
            rid: linux-x64
            exe: PowerShell.MCP.Proxy
          - os: macos-14
            rid: osx-arm64
            exe: PowerShell.MCP.Proxy
    
    runs-on: ${{ matrix.os }}
    timeout-minutes: 15
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'
    
    - name: Install PowerShell 7.5 (Windows)
      if: runner.os == 'Windows'
      run: |
        # GitHub Actions has PowerShell 7.4 which uses .NET 8
        # PowerShell.MCP requires .NET 9, so we need PowerShell 7.5+
        winget install --id Microsoft.PowerShell --source winget --accept-source-agreements --accept-package-agreements
      shell: pwsh

    - name: Install PowerShell (macOS)
      if: runner.os == 'macOS'
      run: |
        brew install powershell/tap/powershell
    
    - name: Install PowerShell (Linux)
      if: runner.os == 'Linux'
      run: |
        # Install PowerShell on Ubuntu
        sudo apt-get update
        sudo apt-get install -y wget apt-transport-https software-properties-common
        source /etc/os-release
        wget -q https://packages.microsoft.com/config/ubuntu/$VERSION_ID/packages-microsoft-prod.deb
        sudo dpkg -i packages-microsoft-prod.deb
        rm packages-microsoft-prod.deb
        sudo apt-get update
        sudo apt-get install -y powershell
    
    - name: Verify PowerShell
      shell: pwsh
      run: |
        Write-Host "PowerShell Version: $($PSVersionTable.PSVersion)"
        Write-Host "OS: $($PSVersionTable.OS)"
    
    - name: Build PowerShell.MCP module
      run: |
        dotnet build PowerShell.MCP -c Release --no-incremental
    
    - name: Build Proxy
      run: |
        dotnet publish PowerShell.MCP.Proxy -c Release -r ${{ matrix.rid }} --self-contained
    
    - name: Setup module directory (Windows)
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        $modulePath = "$env:USERPROFILE\Documents\PowerShell\Modules\PowerShell.MCP"
        New-Item -Path "$modulePath\bin\${{ matrix.rid }}" -ItemType Directory -Force | Out-Null
        
        Copy-Item "PowerShell.MCP\bin\Release\net9.0\PowerShell.MCP.dll" -Destination $modulePath
        Copy-Item "PowerShell.MCP\bin\Release\net9.0\Ude.NetStandard.dll" -Destination $modulePath
        Copy-Item "Staging\PowerShell.MCP.psd1" -Destination $modulePath
        Copy-Item "Staging\PowerShell.MCP.psm1" -Destination $modulePath
        Copy-Item "PowerShell.MCP.Proxy\bin\Release\net9.0\${{ matrix.rid }}\publish\${{ matrix.exe }}" -Destination "$modulePath\bin\${{ matrix.rid }}"
        
        Write-Host "Module files:"
        Get-ChildItem $modulePath -Recurse | Select-Object FullName
    
    - name: Setup module directory (Linux/macOS)
      if: runner.os != 'Windows'
      run: |
        MODULE_PATH="$HOME/.local/share/powershell/Modules/PowerShell.MCP"
        mkdir -p "$MODULE_PATH/bin/${{ matrix.rid }}"
        
        cp PowerShell.MCP/bin/Release/net9.0/PowerShell.MCP.dll "$MODULE_PATH/"
        cp PowerShell.MCP/bin/Release/net9.0/Ude.NetStandard.dll "$MODULE_PATH/"
        cp Staging/PowerShell.MCP.psd1 "$MODULE_PATH/"
        cp Staging/PowerShell.MCP.psm1 "$MODULE_PATH/"
        cp "PowerShell.MCP.Proxy/bin/Release/net9.0/${{ matrix.rid }}/publish/${{ matrix.exe }}" "$MODULE_PATH/bin/${{ matrix.rid }}/"
        chmod +x "$MODULE_PATH/bin/${{ matrix.rid }}/${{ matrix.exe }}"
        
        echo "Module files:"
        ls -laR "$MODULE_PATH/"
    
    - name: Test module import
      shell: pwsh
      run: |
        $ErrorActionPreference = "Stop"
        
        Write-Host "=== Importing module ===" -ForegroundColor Cyan
        Import-Module PowerShell.MCP -Verbose
        
        Write-Host "`n=== Module info ===" -ForegroundColor Cyan
        Get-Module PowerShell.MCP | Format-List Name, Version, ModuleBase
        
        Write-Host "`n=== Get-MCPProxyPath ===" -ForegroundColor Cyan
        $proxyPath = Get-MCPProxyPath
        Write-Host "Proxy path: $proxyPath"
        if (-not (Test-Path $proxyPath)) { throw "Proxy not found at $proxyPath" }
        
        Write-Host "`n=== Get-MCPProxyPath -Escape ===" -ForegroundColor Cyan
        $escapedPath = Get-MCPProxyPath -Escape
        Write-Host "Escaped path: $escapedPath"
        
        Write-Host "`n=== PSReadLine status ===" -ForegroundColor Cyan
        $psrl = Get-Module PSReadLine
        if ($IsWindows) {
          if ($psrl) {
            Write-Host "PSReadLine is loaded (expected on Windows)" -ForegroundColor Green
          } else {
            Write-Host "PSReadLine is NOT loaded (unexpected on Windows)" -ForegroundColor Yellow
          }
        } else {
          if ($psrl) {
            Write-Host "PSReadLine is loaded (unexpected on Linux/macOS)" -ForegroundColor Yellow
          } else {
            Write-Host "PSReadLine is NOT loaded (expected on Linux/macOS)" -ForegroundColor Green
          }
        }
        
        Write-Host "`n=== All tests passed ===" -ForegroundColor Green
    
    - name: Test Proxy JSON-RPC communication
      shell: pwsh
      run: |
        $ErrorActionPreference = "Stop"
        
        Write-Host "=== Testing Proxy JSON-RPC ===" -ForegroundColor Cyan
        $proxyPath = Get-MCPProxyPath
        
        # Start Proxy process with redirected stdin/stdout
        $psi = [System.Diagnostics.ProcessStartInfo]::new()
        $psi.FileName = $proxyPath
        $psi.RedirectStandardInput = $true
        $psi.RedirectStandardOutput = $true
        $psi.RedirectStandardError = $true
        $psi.UseShellExecute = $false
        $psi.CreateNoWindow = $true
        
        $process = [System.Diagnostics.Process]::Start($psi)
        
        function Send-JsonRpc {
          param([string]$Json)
          $process.StandardInput.WriteLine($Json)
          $process.StandardInput.Flush()
          Start-Sleep -Milliseconds 500
          
          # Read available output
          $output = ""
          while ($process.StandardOutput.Peek() -ge 0) {
            $output += [char]$process.StandardOutput.Read()
          }
          return $output
        }
        
        try {
          # Test 1: Initialize
          Write-Host "`n=== Test 1: Initialize ===" -ForegroundColor Yellow
          $initRequest = '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}'
          $response = Send-JsonRpc $initRequest
          Write-Host "Response: $response"
          
          if ($response -match '"protocolVersion"') {
            Write-Host "Initialize: PASSED" -ForegroundColor Green
          } else {
            throw "Initialize failed - no protocolVersion in response"
          }
          
          # Send initialized notification
          $process.StandardInput.WriteLine('{"jsonrpc":"2.0","method":"notifications/initialized"}')
          $process.StandardInput.Flush()
          Start-Sleep -Milliseconds 200
          
          # Test 2: List tools
          Write-Host "`n=== Test 2: List Tools ===" -ForegroundColor Yellow
          $listRequest = '{"jsonrpc":"2.0","id":2,"method":"tools/list","params":{}}'
          $response = Send-JsonRpc $listRequest
          Write-Host "Response: $response"
          
          if ($response -match '"get_current_location"' -and $response -match '"invoke_expression"' -and $response -match '"start_powershell_console"') {
            Write-Host "List Tools: PASSED" -ForegroundColor Green
          } else {
            throw "List Tools failed - expected tools not found"
          }
          
          Write-Host "`n=== All JSON-RPC tests passed ===" -ForegroundColor Green
          
        } finally {
          if (-not $process.HasExited) {
            $process.Kill()
          }
          $process.Dispose()
        }

    - name: Test Named Pipe communication
      shell: pwsh
      run: |
        $ErrorActionPreference = "Stop"
        
        Write-Host "=== Testing Named Pipe Communication ===" -ForegroundColor Cyan
        
        # Start a background pwsh process with PowerShell.MCP imported
        Write-Host "Starting background pwsh with PowerShell.MCP..."
        $bgPsi = [System.Diagnostics.ProcessStartInfo]::new()
        $bgPsi.FileName = "pwsh"
        $bgPsi.Arguments = "-NoProfile -NoExit -Command `"Import-Module PowerShell.MCP; while (`$true) { Start-Sleep -Seconds 1 }`""
        $bgPsi.UseShellExecute = $false
        $bgPsi.CreateNoWindow = $true
        $bgPsi.RedirectStandardInput = $true
        $bgPsi.RedirectStandardOutput = $true
        $bgPsi.RedirectStandardError = $true
        
        $bgProcess = [System.Diagnostics.Process]::Start($bgPsi)
        Write-Host "Background pwsh PID: $($bgProcess.Id)"
        
        # Wait for Named Pipe server to be ready
        Write-Host "Waiting for Named Pipe server..."
        $pipeName = "PowerShell.MCP.$($bgProcess.Id)"
        $pipeReady = $false
        for ($i = 0; $i -lt 30; $i++) {
          Start-Sleep -Milliseconds 500
          if ($IsWindows) {
            $pipeReady = Test-Path "\\.\pipe\$pipeName"
          } else {
            $pipeReady = Test-Path "/tmp/CoreFxPipe_$pipeName"
          }
          if ($pipeReady) {
            Write-Host "Named Pipe ready after $($i * 500)ms"
            break
          }
        }
        
        if (-not $pipeReady) {
          $bgProcess.Kill()
          throw "Named Pipe server did not start within 15 seconds"
        }
        
        # Start Proxy
        Write-Host "Starting Proxy..."
        $proxyPath = Get-MCPProxyPath
        $psi = [System.Diagnostics.ProcessStartInfo]::new()
        $psi.FileName = $proxyPath
        $psi.RedirectStandardInput = $true
        $psi.RedirectStandardOutput = $true
        $psi.RedirectStandardError = $true
        $psi.UseShellExecute = $false
        $psi.CreateNoWindow = $true
        
        $process = [System.Diagnostics.Process]::Start($psi)
        
        function Send-JsonRpc {
          param([string]$Json, [int]$WaitMs = 2000)
          $process.StandardInput.WriteLine($Json)
          $process.StandardInput.Flush()
          Start-Sleep -Milliseconds $WaitMs
          
          $output = ""
          while ($process.StandardOutput.Peek() -ge 0) {
            $output += [char]$process.StandardOutput.Read()
          }
          return $output
        }
        
        try {
          # Initialize
          $initRequest = '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}'
          $null = Send-JsonRpc $initRequest
          $process.StandardInput.WriteLine('{"jsonrpc":"2.0","method":"notifications/initialized"}')
          $process.StandardInput.Flush()
          Start-Sleep -Milliseconds 200
          
          # Test: invoke_expression with Get-Date
          Write-Host "`n=== Test: invoke_expression (Get-Date) ===" -ForegroundColor Yellow
          $invokeRequest = '{"jsonrpc":"2.0","id":10,"method":"tools/call","params":{"name":"invoke_expression","arguments":{"pipeline":"Get-Date -Format yyyy-MM-dd"}}}'
          $response = Send-JsonRpc $invokeRequest 3000
          Write-Host "Response: $response"
          
          $today = Get-Date -Format "yyyy-MM-dd"
          if ($response -match $today) {
            Write-Host "invoke_expression (Get-Date): PASSED - Got today's date" -ForegroundColor Green
          } else {
            throw "invoke_expression failed - expected date $today not found in response"
          }
          
          # Test: get_current_location
          Write-Host "`n=== Test: get_current_location ===" -ForegroundColor Yellow
          $locRequest = '{"jsonrpc":"2.0","id":11,"method":"tools/call","params":{"name":"get_current_location","arguments":{}}}'
          $response = Send-JsonRpc $locRequest 3000
          Write-Host "Response: $response"
          
          if ($response -match '"current_location"' -or $response -match '"system"') {
            Write-Host "get_current_location: PASSED" -ForegroundColor Green
          } else {
            throw "get_current_location failed - no location info in response"
          }
          
          Write-Host "`n=== All Named Pipe tests passed ===" -ForegroundColor Green
          
        } finally {
          if (-not $process.HasExited) { $process.Kill() }
          $process.Dispose()
          if (-not $bgProcess.HasExited) { $bgProcess.Kill() }
          $bgProcess.Dispose()
        }
