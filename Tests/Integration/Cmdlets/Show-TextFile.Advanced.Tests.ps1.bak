Describe "Show-TextFile - Context Display and ANSI Highlighting Tests" {
    BeforeAll {
        $script:testFile = [System.IO.Path]::GetTempFileName()
    }

    AfterAll {
        Remove-Item $script:testFile -Force -ErrorAction SilentlyContinue
    }

    Context "コンテキスト表示（前後2行）" {
        It "マッチ行の前後2行が表示される" {
            $content = @(
                "Line 1"
                "Line 2"
                "Line 3"
                "Line 4"
                "Target Line 5"
                "Line 6"
                "Line 7"
                "Line 8"
                "Line 9"
            )
            Set-Content -Path $script:testFile -Value $content -Encoding UTF8
            $result = Show-TextFile -Path $script:testFile -Contains "Target"
            
            # ヘッダー行 + 前2行 + マッチ行 + 後2行 = 6行
            $result.Count | Should -Be 6
            # ヘッダー行をスキップして検証
            $contentLines = $result | Select-Object -Skip 1
            $contentLines[0] | Should -Match "Line 3"
            $contentLines[2] | Should -Match ":.*5.*Target"  # マッチ行に:マーク
            $contentLines[4] | Should -Match "Line 7"
        }

        It "ファイル先頭のマッチではコンテキストが先頭から始まる" {
            $content = @(
                "Target Line 1"
                "Line 2"
                "Line 3"
                "Line 4"
            )
            Set-Content -Path $script:testFile -Value $content -Encoding UTF8
            $result = Show-TextFile -Path $script:testFile -Contains "Target"
            
            # ヘッダー行をスキップして検証
            $contentLines = $result | Select-Object -Skip 1
            # 先頭行なので、1行目から開始（前のコンテキストなし）
            $contentLines[0] | Should -Match "\*.*1.*Target"
            $contentLines[-1] | Should -Match "Line 4"
        }

        It "ファイル末尾のマッチではコンテキストが末尾で終わる" {
            $content = @(
                "Line 1"
                "Line 2"
                "Line 3"
                "Target Line 4"
            )
            Set-Content -Path $script:testFile -Value $content -Encoding UTF8
            $result = Show-TextFile -Path $script:testFile -Contains "Target"
            
            # ヘッダー行をスキップして検証
            $contentLines = $result | Select-Object -Skip 1
            # 末尾行なので、最後まで表示（後のコンテキストなし）
            $contentLines[0] | Should -Match "Line 1"
            $contentLines[-1] | Should -Match "\*.*4.*Target"
        }

        It "複数マッチがある場合、近接する範囲がマージされる" {
            $content = @(
                "Line 1"
                "Target Line 2"
                "Line 3"
                "Target Line 4"  # 前のマッチから2行しか離れていない
                "Line 5"
                "Line 6"
            )
            Set-Content -Path $script:testFile -Value $content -Encoding UTF8
            $result = Show-TextFile -Path $script:testFile -Contains "Target"
            
            # 2つのマッチが近接しているため、範囲がマージされて連続表示
            # 空行が挿入されない（ヘッダー行以外）
            $contentLines = $result | Select-Object -Skip 1
            $contentLines | Where-Object { $_ -eq "" } | Should -BeNullOrEmpty
        }

        It "複数マッチが離れている場合、範囲が分離される" {
            $content = @(
                "Target Line 1"
                "Line 2"
                "Line 3"
                "Line 4"
                "Line 5"
                "Line 6"
                "Line 7"
                "Line 8"
                "Target Line 9"
            )
            Set-Content -Path $script:testFile -Value $content -Encoding UTF8
            $result = Show-TextFile -Path $script:testFile -Contains "Target"
            
            # 2つのマッチが離れているため、空行で区切られる
            $contentLines = $result | Select-Object -Skip 1
            $emptyLines = $contentLines | Where-Object { $_ -eq "" }
            $emptyLines.Count | Should -BeGreaterThan 0
        }
    }

    Context "ANSI エスケープシーケンスによるハイライト" {
        It "Contains マッチ部分に ANSI 反転表示が適用される" {
            Set-Content -Path $script:testFile -Value "This is a Target word" -Encoding UTF8
            $result = Show-TextFile -Path $script:testFile -Contains "Target"
            
            # ANSI エスケープシーケンス \e[7m (反転ON) と \e[0m (リセット) が含まれる
            $matchLine = $result | Where-Object { $_ -match "\*" }
            $matchLine | Should -Match "$([char]27)\[7m"  # 反転ON
            $matchLine | Should -Match "$([char]27)\[0m"  # リセット
        }

        It "Pattern マッチ部分に ANSI 反転表示が適用される" {
            Set-Content -Path $script:testFile -Value "Error: Something went wrong" -Encoding UTF8
            $result = Show-TextFile -Path $script:testFile -Pattern "Error:"
            
            $matchLine = $result | Where-Object { $_ -match "\*" }
            $matchLine | Should -Match "$([char]27)\[7m"
            $matchLine | Should -Match "$([char]27)\[0m"
        }

        It "コンテキスト行には ANSI が適用されない" {
            $content = @(
                "Line 1"
                "Target Line 2"
                "Line 3"
            )
            Set-Content -Path $script:testFile -Value $content -Encoding UTF8
            $result = Show-TextFile -Path $script:testFile -Contains "Target"
            
            # コンテキスト行（*マークなし、ヘッダーでもない）には ANSI エスケープが含まれない
            $contextLines = $result | Where-Object { 
                $_ -notmatch "\*" -and $_ -ne "" -and $_ -notmatch "^==>"
            }
            foreach ($line in $contextLines) {
                $line | Should -Not -Match "$([char]27)\["
            }
        }
    }

    Context "LineRange と検索の組み合わせ" {
        It "LineRange 内でのみ検索が実行される" {
            $content = @(
                "Target Line 1"
                "Line 2"
                "Line 3"
                "Line 4"
                "Target Line 5"
                "Line 6"
            )
            Set-Content -Path $script:testFile -Value $content -Encoding UTF8
            # 3-6行目の範囲でのみ検索
            $result = Show-TextFile -Path $script:testFile -LineRange 3,6 -Contains "Target"
            
            # Line 5 のみがマッチ（Line 1 は範囲外）
            $result | Where-Object { $_ -match "\*" } | Should -HaveCount 1
            $result | Where-Object { $_ -match "Line 5" } | Should -Not -BeNullOrEmpty
        }
    }
}

Describe "LineRange - Negative Values Support (End of File)" {
    BeforeAll {
        $script:testFile = [System.IO.Path]::GetTempFileName()
        $script:content = @(
            "Line 1"
            "Line 2"
            "Line 3"
            "Line 4"
            "Line 5"
            "Line 6"
            "Line 7"
            "Line 8"
            "Line 9"
            "Line 10"
        )
    }

    AfterAll {
        Remove-Item $script:testFile -Force -ErrorAction SilentlyContinue
    }

    Context "Show-TextFile での負の LineRange" {
        It "-LineRange 5,-1 で5行目から最後まで表示" {
            Set-Content -Path $script:testFile -Value $script:content -Encoding UTF8
            $result = Show-TextFile -Path $script:testFile -LineRange 5,-1
            
            # ヘッダー行 + 6行（Line 5-10）
            $result.Count | Should -Be 7
            $contentLines = $result | Select-Object -Skip 1
            $contentLines[0] | Should -Match "Line 5"
            $contentLines[-1] | Should -Match "Line 10"
        }

        It "-LineRange 8,0 で8行目から最後まで表示（0も末尾を意味する）" {
            Set-Content -Path $script:testFile -Value $script:content -Encoding UTF8
            $result = Show-TextFile -Path $script:testFile -LineRange 8,0
            
            # ヘッダー行 + 3行（Line 8-10）
            $result.Count | Should -Be 4
            $contentLines = $result | Select-Object -Skip 1
            $contentLines[0] | Should -Match "Line 8"
            $contentLines[-1] | Should -Match "Line 10"
        }

        It "-LineRange 1,-1 でファイル全体を表示" {
            Set-Content -Path $script:testFile -Value $script:content -Encoding UTF8
            $result = Show-TextFile -Path $script:testFile -LineRange 1,-1
            
            # ヘッダー行 + 10行
            $result.Count | Should -Be 11
        }
    }

    Context "Remove-LinesFromFile での負の LineRange" {
        It "-LineRange 5,-1 で5行目から最後まで削除" {
            Set-Content -Path $script:testFile -Value $script:content -Encoding UTF8
            Remove-LinesFromFile -Path $script:testFile -LineRange 5,-1
            $result = Get-Content $script:testFile
            
            $result.Count | Should -Be 4  # Line 1-4 のみ残る
            $result[-1] | Should -Be "Line 4"
        }

        It "-LineRange 8,0 で8行目から最後まで削除" {
            Set-Content -Path $script:testFile -Value $script:content -Encoding UTF8
            Remove-LinesFromFile -Path $script:testFile -LineRange 8,0
            $result = Get-Content $script:testFile
            
            $result.Count | Should -Be 7  # Line 1-7 のみ残る
            $result[-1] | Should -Be "Line 7"
        }
    }

    Context "Update-LinesInFile での負の LineRange" {
        It "-LineRange 5,-1 で5行目から最後まで置換" {
            Set-Content -Path $script:testFile -Value $script:content -Encoding UTF8
            Update-LinesInFile -Path $script:testFile -LineRange 5,-1 -Content "Replaced"
            $result = Get-Content $script:testFile
            
            $result.Count | Should -Be 5  # Line 1-4 + Replaced
            $result[0..3] | Should -Be @("Line 1", "Line 2", "Line 3", "Line 4")
            $result[4] | Should -Be "Replaced"
        }
    }

    Context "Test-TextFileContains での負の LineRange" {
        It "-LineRange 5,-1 で5行目から最後まで検索" {
            Set-Content -Path $script:testFile -Value $script:content -Encoding UTF8
            
            # Line 7 は範囲内（5-10）なので見つかる
            $result = Test-TextFileContains -Path $script:testFile -LineRange 5,-1 -Contains "Line 7"
            $result | Should -Be $true
            
            # Line 2 は範囲外（1-4）なので見つからない
            $result = Test-TextFileContains -Path $script:testFile -LineRange 5,-1 -Contains "Line 2"
            $result | Should -Be $false
        }
    }

    Context "Update-MatchInFile での負の LineRange" {
        It "-LineRange 5,-1 で5行目から最後までの範囲で置換" {
            Set-Content -Path $script:testFile -Value $script:content -Encoding UTF8
            Update-MatchInFile -Path $script:testFile -LineRange 5,-1 -Contains "Line" -Replacement "Row"
            $result = Get-Content $script:testFile
            
            # 1-4行目は変更なし
            $result[0..3] | Should -Be @("Line 1", "Line 2", "Line 3", "Line 4")
            # 5-10行目は置換される
            $result[4..9] | ForEach-Object { $_ | Should -Match "Row" }
        }
    }
}