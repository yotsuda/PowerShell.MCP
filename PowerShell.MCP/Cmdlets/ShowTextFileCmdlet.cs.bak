using System.Management.Automation;
using System.Text.RegularExpressions;
using System.Linq;

namespace PowerShell.MCP.Cmdlets;

/// <summary>
/// テキストファイルの内容を行番号付きで表示
/// LLM最適化：行番号は3桁、マッチ行は:でコンテキスト行は-で区別（grep標準）、常にカレントディレクトリからの相対パスを表示
/// </summary>
[Cmdlet(VerbsCommon.Show, "TextFile")]
public class ShowTextFileCmdlet : TextFileCmdletBase
{
    [Parameter(ParameterSetName = "Path", Mandatory = true, Position = 0, ValueFromPipelineByPropertyName = true)]
    [SupportsWildcards]
    public string[] Path { get; set; } = null!;

    [Parameter(ParameterSetName = "LiteralPath", Mandatory = true, ValueFromPipelineByPropertyName = true)]
    [Alias("PSPath")]
    public string[] LiteralPath { get; set; } = null!;

    [Parameter]
    [ValidateLineRange]
    public int[]? LineRange { get; set; }

    [Parameter(ParameterSetName = "Path")]
    [Parameter(ParameterSetName = "LiteralPath")]
    public string? Pattern { get; set; }
    
    [Parameter(ParameterSetName = "Path")]
    [Parameter(ParameterSetName = "LiteralPath")]
    public string? Contains { get; set; }


    [Parameter]
    public string? Encoding { get; set; }

    private int _totalFilesProcessed = 0;


    protected override void BeginProcessing()
    {
        ValidateContainsAndPatternMutuallyExclusive(Contains, Pattern);
    }

    protected override void ProcessRecord()
    {
        // LineRangeバリデーション
        ValidateLineRange(LineRange);

        // ResolveAndValidateFiles は IEnumerable を返すので、遅延評価のまま処理
        var files = ResolveAndValidateFiles(Path, LiteralPath, allowNewFiles: false, requireExisting: true);

        foreach (var fileInfo in files)
        {
            try
            {
                // ファイル間の空行（最初のファイル以外）
                if (_totalFilesProcessed > 0)
                {
                    WriteObject("");
                }
                
                // 表示用パスを決定（PS Drive パスを保持）
                var displayPath = GetDisplayPath(fileInfo.InputPath, fileInfo.ResolvedPath);
                WriteObject($"==> {displayPath} <==");
                
                _totalFilesProcessed++;

                var encoding = TextFileUtility.GetEncoding(fileInfo.ResolvedPath, Encoding);

                // 空ファイルの処理
                var fileInfoObj = new FileInfo(fileInfo.ResolvedPath);
                if (fileInfoObj.Length == 0)
                {
                    WriteWarning("File is empty");
                    continue;
                }

                if (!string.IsNullOrEmpty(Pattern))
                {
                    ShowWithPattern(fileInfo.ResolvedPath, encoding);
                }
                else if (!string.IsNullOrEmpty(Contains))
                {
                    ShowWithContains(fileInfo.ResolvedPath, encoding);
                }
                else
                {
                    ShowWithLineRange(fileInfo.ResolvedPath, encoding);
                }
            }
            catch (Exception ex)
            {
                WriteError(new ErrorRecord(ex, "ShowTextFileFailed", ErrorCategory.ReadError, fileInfo.ResolvedPath));
            }
        }
    }


    private void ShowWithLineRange(string filePath, System.Text.Encoding encoding)
    {
        var (startLine, endLine) = TextFileUtility.ParseLineRange(LineRange);

        // Skip/Take で必要な範囲だけを取得（LINQの遅延評価で効率的）
        int skipCount = startLine - 1;
        int takeCount = endLine - startLine + 1;

        var lines = File.ReadLines(filePath, encoding)
            .Skip(skipCount)
            .Take(takeCount);

        int currentLine = startLine;
        bool hasOutput = false;

        foreach (var line in lines)
        {
            WriteObject($"{currentLine,3}: {line}");
            currentLine++;
            hasOutput = true;
        }

        // 1行も出力されなかった場合のみメッセージ
        if (!hasOutput && LineRange != null)
        {
            WriteWarning($"Line range {startLine}-{endLine} is beyond file length. No output.");
        }
    }

    private void ShowWithPattern(string filePath, System.Text.Encoding encoding)
    {
        var regex = new Regex(Pattern, RegexOptions.Compiled);
        ShowWithMatch(filePath, encoding, line => regex.IsMatch(line), "pattern", Pattern, true);
    }

    private void ShowWithContains(string filePath, System.Text.Encoding encoding)
    {
        ShowWithMatch(filePath, encoding, 
            line => line.Contains(Contains!, StringComparison.Ordinal), 
            "contain", Contains!, false);
    }

    /// <summary>
    /// マッチ条件に基づいて行を検索し、前後の文脈と共に表示（1パス実装）
    /// </summary>
    private void ShowWithMatch(
        string filePath, 
        System.Text.Encoding encoding, 
        Func<string, bool> matchPredicate,
        string matchTypeForWarning,
        string matchValue,
        bool isRegex)
    {
        var (startLine, endLine) = TextFileUtility.ParseLineRange(LineRange);
        
        // コンテキスト範囲を計算（前後2行を含む）
        int contextStartLine = Math.Max(1, startLine - 2);
        int contextEndLine = endLine + 2;
        
        var matchedLines = new List<int>();
        var contextBuffer = new Dictionary<int, string>();
        
        // ANSIエスケープシーケンス（反転表示）
        string reverseOn = $"{(char)27}[7m";
        string reverseOff = $"{(char)27}[0m";
        
        using (var enumerator = File.ReadLines(filePath, encoding).GetEnumerator())
        {
            // contextStartLine まで移動
            int skipCount = 0;
            while (skipCount < contextStartLine - 1 && enumerator.MoveNext())
            {
                skipCount++;
            }
            
            if (!enumerator.MoveNext())
            {
                // ファイルが範囲外
                WriteWarning($"Line range {startLine}-{endLine} is beyond file length. No output.");
                return;
            }
            
            int lineNumber = contextStartLine;
            string currentLine = enumerator.Current;
            bool hasNext = enumerator.MoveNext();
            
            // Rotate buffer: 前2行を保持
            string? prevPrevLine = null;
            string? prevLine = null;
            
            // 後続コンテキストカウンタ
            int afterMatchCounter = 0;
            
            // 最後にマッチした行番号
            int lastMatchLine = 0;
            
            while (true)
            {
                // マッチ判定は元の LineRange 内のみで行う
                bool matched = (lineNumber >= startLine && lineNumber <= endLine) && matchPredicate(currentLine);
                
                if (matched)
                {
                    // 前2行をバッファに追加（マッチを含む場合は反転表示を適用）
                    if (prevPrevLine != null && lineNumber - 2 >= 1)
                    {
                        contextBuffer[lineNumber - 2] = ApplyHighlightingIfMatched(prevPrevLine, matchPredicate, matchValue, isRegex, reverseOn, reverseOff);
                    }
                    if (prevLine != null && lineNumber - 1 >= 1)
                    {
                        contextBuffer[lineNumber - 1] = ApplyHighlightingIfMatched(prevLine, matchPredicate, matchValue, isRegex, reverseOn, reverseOff);
                    }
                    // 反転表示を構築
                    string displayLine;
                    if (isRegex)
                    {
                        var regex = new Regex(matchValue, RegexOptions.Compiled);
                        displayLine = regex.Replace(currentLine, m => $"{reverseOn}{m.Value}{reverseOff}");
                    }
                    else
                    {
                        displayLine = currentLine.Replace(matchValue, $"{reverseOn}{matchValue}{reverseOff}");
                    }
                    
                    contextBuffer[lineNumber] = displayLine;
                    matchedLines.Add(lineNumber);
                    
                    afterMatchCounter = 2;
                    lastMatchLine = lineNumber;
                }
                else
                {
                    // 後続コンテキストの収集（マッチを含む場合は反転表示を適用）
                    if (afterMatchCounter > 0)
                    {
                        contextBuffer[lineNumber] = ApplyHighlightingIfMatched(currentLine, matchPredicate, matchValue, isRegex, reverseOn, reverseOff);
                        afterMatchCounter--;
                    }
                }
                
                // Rotate buffer更新（元の行を保存）
                prevPrevLine = prevLine;
                prevLine = currentLine;
                
                // 終了条件：
                // 1. 次の行がない
                // 2. contextEndLine を超えた かつ 後続コンテキストの収集が完了した
                if (!hasNext)
                {
                    break;
                }
                
                if (lineNumber >= contextEndLine && afterMatchCounter == 0)
                {
                    break;
                }
                
                // 次へ
                lineNumber++;
                currentLine = enumerator.Current;
                hasNext = enumerator.MoveNext();
            }
        }

        
        // マッチが見つからない場合
        if (matchedLines.Count == 0)
        {
            string message = matchTypeForWarning == "pattern" 
                ? $"No lines matched pattern: {matchValue}"
                : $"No lines contain: {matchValue}";
            WriteWarning(message);
            return;
        }
        
        // 範囲を計算してマージ
        var sortedLineNumbers = contextBuffer.Keys.OrderBy(x => x).ToList();
        var ranges = CalculateAndMergeRangesFromBuffer(sortedLineNumbers);
        
        // バッファから出力（ファイル再読込なし）
        OutputFromBuffer(contextBuffer, matchedLines, ranges);
    }

    /// <summary>
    /// バッファから範囲を計算してマージ
    /// </summary>
    private List<(int start, int end)> CalculateAndMergeRangesFromBuffer(List<int> lineNumbers)
    {
        var ranges = new List<(int start, int end)>();
        if (lineNumbers.Count == 0) return ranges;

        int currentStart = lineNumbers[0];
        int currentEnd = lineNumbers[0];

        for (int i = 1; i < lineNumbers.Count; i++)
        {
            int lineNumber = lineNumbers[i];
            
            // 現在の範囲と隣接または重複している場合、範囲を拡張
            if (lineNumber <= currentEnd + 1)
            {
                currentEnd = lineNumber;
            }
            else
            {
                // 範囲を確定
                ranges.Add((currentStart, currentEnd));
                currentStart = lineNumber;
                currentEnd = lineNumber;
            }
        }
        
        // 最後の範囲を追加
        ranges.Add((currentStart, currentEnd));

        return ranges;
    }

    /// <summary>
    /// マッチした行とその前後のコンテキストを表示（バッファから、ファイル再読込なし）
    /// </summary>
    private void OutputFromBuffer(Dictionary<int, string> contextBuffer, List<int> matchedLines, List<(int start, int end)> ranges)
    {
        if (matchedLines.Count == 0) return;

        var matchedSet = new HashSet<int>(matchedLines);
        
        // 範囲ごとに出力
        for (int rangeIndex = 0; rangeIndex < ranges.Count; rangeIndex++)
        {
            var (start, end) = ranges[rangeIndex];
            
            for (int lineNumber = start; lineNumber <= end; lineNumber++)
            {
                if (contextBuffer.ContainsKey(lineNumber))
                {
                    string separator = matchedSet.Contains(lineNumber) ? ":" : "-";
                    WriteObject($"{lineNumber,3}{separator} {contextBuffer[lineNumber]}");
                }
            }
            
            // 次の範囲との間に空行
            if (rangeIndex < ranges.Count - 1)
            {
                WriteObject("");
            }
        }
    }
    
    /// <summary>
    /// 行にマッチが含まれる場合、反転表示を適用する
    /// </summary>
    private string ApplyHighlightingIfMatched(string line, Func<string, bool> matchPredicate, string matchValue, bool isRegex, string reverseOn, string reverseOff)
    {
        if (!matchPredicate(line))
        {
            return line;
        }
        
        if (isRegex)
        {
            var regex = new Regex(matchValue, RegexOptions.Compiled);
            return regex.Replace(line, m => $"{reverseOn}{m.Value}{reverseOff}");
        }
        else
        {
            return line.Replace(matchValue, $"{reverseOn}{matchValue}{reverseOff}");
        }
    }
}